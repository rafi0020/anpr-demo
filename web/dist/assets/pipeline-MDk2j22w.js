var C=Object.defineProperty;var D=(g,t,e)=>t in g?C(g,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):g[t]=e;var l=(g,t,e)=>D(g,typeof t!="symbol"?t+"":t,e);class v{constructor(t=1e3){l(this,"logs",[]);l(this,"maxLogs",1e3);l(this,"listeners",new Set);this.maxLogs=t}log(t,e,o={},n="info"){const s={timestamp:Date.now(),module:t,message:e,data:o,level:n};this.logs.push(s),this.logs.length>this.maxLogs&&this.logs.shift(),this.listeners.forEach(i=>i(s)),(n==="error"?console.error:n==="warn"?console.warn:n==="debug"?console.debug:console.log)(`[${t}] ${e}`,o)}info(t,e,o={}){this.log(t,e,o,"info")}warn(t,e,o={}){this.log(t,e,o,"warn")}error(t,e,o={}){this.log(t,e,o,"error")}debug(t,e,o={}){this.log(t,e,o,"debug")}getLogs(t){return t?this.logs.filter(e=>!(t.module&&e.module!==t.module||t.level&&e.level!==t.level)):[...this.logs]}getRecentLogs(t=50){return this.logs.slice(-t)}clearLogs(){this.logs=[]}subscribe(t){return this.listeners.add(t),()=>this.listeners.delete(t)}exportLogs(){return JSON.stringify(this.logs,null,2)}exportReport(){var s,r;const t={info:0,warn:0,error:0,debug:0},e={};this.logs.forEach(i=>{t[i.level]++,e[i.module]=(e[i.module]||0)+1});const o=((s=this.logs[0])==null?void 0:s.timestamp)||0,n=((r=this.logs[this.logs.length-1])==null?void 0:r.timestamp)||0;return{summary:{totalLogs:this.logs.length,byLevel:t,byModule:e},logs:[...this.logs],timeline:{startTime:o,endTime:n,duration:n-o}}}formatLog(t){const o=new Date(t.timestamp).toLocaleTimeString("en-US",{hour12:!1,hour:"2-digit",minute:"2-digit",second:"2-digit"}),n=String(t.timestamp%1e3).padStart(3,"0");return`${o}.${n} ${{info:"â„¹ï¸",warn:"âš ï¸",error:"âŒ",debug:"ðŸ”"}[t.level]} [${t.module}] ${t.message}`}getLogsByModule(){const t=new Map;return this.logs.forEach(e=>{t.has(e.module)||t.set(e.module,[]),t.get(e.module).push(e)}),t}getPerformanceMetrics(){const t=new Map;this.logs.forEach((n,s)=>{t.has(n.module)||t.set(n.module,{count:0,startTime:n.timestamp,totalDuration:0});const r=t.get(n.module);if(r.count++,s<this.logs.length-1){const a=this.logs[s+1].timestamp-n.timestamp;r.totalDuration+=a}});const e=Array.from(t.entries()).map(([n,s])=>({name:n,count:s.count,duration:s.totalDuration,avgDuration:s.totalDuration/s.count})),o=this.logs.length>0?this.logs[this.logs.length-1].timestamp-this.logs[0].timestamp:0;return{modules:e,totalDuration:o}}}class T{constructor(t){l(this,"detectionData",null);l(this,"logger");l(this,"frameIndex",new Map);l(this,"timeTolerance",100);this.logger=t}async loadDetections(t){var e,o,n;try{this.logger.info("DetectorPrecomputed","Loading detections",{url:t});const s=await fetch(t);if(!s.ok)throw new Error(`Failed to load detections: ${s.statusText}`);this.detectionData=await s.json(),this.buildFrameIndex(),this.logger.info("DetectorPrecomputed","Detections loaded",{videoId:(e=this.detectionData)==null?void 0:e.videoId,frameCount:(o=this.detectionData)==null?void 0:o.frames.length,fps:(n=this.detectionData)==null?void 0:n.fps})}catch(s){throw this.logger.error("DetectorPrecomputed","Failed to load detections",{error:s}),s}}buildFrameIndex(){this.detectionData&&(this.frameIndex.clear(),this.detectionData.frames.forEach(t=>{const e=Math.round(t.timeMs/100)*100;this.frameIndex.set(e,t)}),this.logger.debug("DetectorPrecomputed","Frame index built",{buckets:this.frameIndex.size}))}getDetections(t){if(!this.detectionData)return this.logger.warn("DetectorPrecomputed","No detection data loaded"),[];const e=this.findNearestFrame(t);return e?(this.logger.debug("DetectorPrecomputed","Detections retrieved",{timeMs:t,frameTime:e.timeMs,detectionCount:e.detections.length}),e.detections):(this.logger.debug("DetectorPrecomputed","No frame found",{timeMs:t}),[])}findNearestFrame(t){if(!this.detectionData)return null;const e=this.detectionData.frames.find(i=>i.timeMs===t);if(e)return e;const o=Math.round(t/100)*100,n=this.frameIndex.get(o);if(n&&Math.abs(n.timeMs-t)<=this.timeTolerance)return n;let s=null,r=1/0;for(const i of this.detectionData.frames){const a=Math.abs(i.timeMs-t);a<=this.timeTolerance&&a<r&&(r=a,s=i)}return s}getFrameAtTime(t){return this.findNearestFrame(t)}getPlateDetections(t){return this.getDetections(t).filter(o=>o.type==="plate")}getVehicleDetections(t){return this.getDetections(t).filter(o=>o.type==="vehicle")}getDetectionRange(t,e){return this.detectionData?this.detectionData.frames.filter(o=>o.timeMs>=t&&o.timeMs<=e):[]}interpolateDetections(t){if(!this.detectionData)return[];const e=this.detectionData.frames;let o=null,n=null;for(let i=0;i<e.length;i++)if(e[i].timeMs<=t&&(o=e[i]),e[i].timeMs>=t&&!n){n=e[i];break}if(!o||!n||o===n)return this.getDetections(t);const s=(t-o.timeMs)/(n.timeMs-o.timeMs),r=[];return o.detections.forEach(i=>{const a=n.detections.find(c=>c.trackId===i.trackId&&c.type===i.type);if(a){const c=[Math.round(i.bbox[0]+(a.bbox[0]-i.bbox[0])*s),Math.round(i.bbox[1]+(a.bbox[1]-i.bbox[1])*s),Math.round(i.bbox[2]+(a.bbox[2]-i.bbox[2])*s),Math.round(i.bbox[3]+(a.bbox[3]-i.bbox[3])*s)],h=i.conf+(a.conf-i.conf)*s;r.push({type:i.type,bbox:c,conf:h,trackId:i.trackId})}}),this.logger.debug("DetectorPrecomputed","Interpolated detections",{timeMs:t,frameBefore:o.timeMs,frameAfter:n.timeMs,alpha:s,interpolatedCount:r.length}),r}getMetadata(){var t;return((t=this.detectionData)==null?void 0:t.metadata)||null}getResolution(){var t;return((t=this.detectionData)==null?void 0:t.resolution)||null}getFPS(){var t;return((t=this.detectionData)==null?void 0:t.fps)||30}isLoaded(){return this.detectionData!==null}clear(){this.detectionData=null,this.frameIndex.clear(),this.logger.info("DetectorPrecomputed","Cleared detection data")}getStatistics(){if(!this.detectionData)return null;let t=0,e=0,o=0;this.detectionData.frames.forEach(r=>{t+=r.detections.length,e+=r.detections.filter(i=>i.type==="plate").length,o+=r.detections.filter(i=>i.type==="vehicle").length});const n=this.detectionData.frames,s=n.length>0?{start:n[0].timeMs,end:n[n.length-1].timeMs}:{start:0,end:0};return{totalFrames:n.length,totalDetections:t,plateDetections:e,vehicleDetections:o,timeRange:s,avgDetectionsPerFrame:n.length>0?t/n.length:0}}}class P{constructor(t,e){l(this,"tracks",new Map);l(this,"nextTrackId",1);l(this,"logger");l(this,"iouThreshold",.3);l(this,"maxLostFrames",10);l(this,"minDetections",3);l(this,"frameCount",0);this.logger=t,this.iouThreshold=(e==null?void 0:e.iouThreshold)??this.iouThreshold,this.maxLostFrames=(e==null?void 0:e.maxLostFrames)??this.maxLostFrames,this.minDetections=(e==null?void 0:e.minDetections)??this.minDetections}update(t,e){this.frameCount++,this.logger.debug("TrackerSimple","Update cycle",{frameCount:this.frameCount,timeMs:e,detectionCount:t.length,activeTrackCount:this.getActiveTracks().length}),this.tracks.forEach(n=>{n.status==="active"&&(n.status="lost")});const o=[];for(const n of t){if(n.type!=="plate")continue;let s=null,r=0;this.tracks.forEach(i=>{if(i.status==="finished")return;const a=this.calculateIOU(n.bbox,i.bbox);a>this.iouThreshold&&a>r&&(r=a,s=i)}),s!==null?(this.updateTrack(s,n,e),n.trackId=s.id,this.logger.debug("TrackerSimple","Matched detection to track",{trackId:s.id,iou:r,confidence:n.conf})):o.push(n)}for(const n of o){const s=this.createTrack(n,e);n.trackId=s.id,this.logger.info("TrackerSimple","Created new track",{trackId:s.id,bbox:n.bbox,confidence:n.conf})}return this.handleLostTracks(e),this.getActiveTracks()}createTrack(t,e){const o={id:String(this.nextTrackId++),status:"active",startTime:e,lastSeen:e,detections:[t],bbox:[...t.bbox],confidence:t.conf};return this.tracks.set(String(o.id),o),o}updateTrack(t,e,o){t.status="active",t.lastSeen=o,t.detections.push(e),t.bbox=[...e.bbox],t.confidence=t.confidence*.7+e.conf*.3}handleLostTracks(t){this.tracks.forEach((o,n)=>{o.status==="lost"&&Math.round((t-o.lastSeen)/33)>this.maxLostFrames&&(o.status="finished",this.logger.info("TrackerSimple","Track finished",{trackId:o.id,duration:t-o.startTime,detectionCount:o.detections.length}))});const e=Array.from(this.tracks.values()).filter(o=>o.status==="finished").sort((o,n)=>n.lastSeen-o.lastSeen);e.length>10&&e.slice(10).forEach(o=>{this.tracks.delete(String(o.id)),this.logger.debug("TrackerSimple","Removed old track",{trackId:o.id})})}calculateIOU(t,e){const[o,n,s,r]=t,[i,a,c,h]=e,d=Math.max(o,i),u=Math.max(n,a),f=Math.min(s,c),m=Math.min(r,h);if(f<d||m<u)return 0;const p=(f-d)*(m-u),x=(s-o)*(r-n),y=(c-i)*(h-a),b=x+y-p;return p/b}getTrack(t){return this.tracks.get(String(t))||null}getActiveTracks(){return Array.from(this.tracks.values()).filter(t=>t.status==="active")}getLostTracks(){return Array.from(this.tracks.values()).filter(t=>t.status==="lost")}getFinishedTracks(){return Array.from(this.tracks.values()).filter(t=>t.status==="finished")}getAllTracks(){return Array.from(this.tracks.values())}reset(){this.tracks.clear(),this.nextTrackId=1,this.frameCount=0,this.logger.info("TrackerSimple","Tracker reset")}getStatistics(){const t=Array.from(this.tracks.values()),e=t.filter(i=>i.status==="active"),o=t.filter(i=>i.status==="lost"),n=t.filter(i=>i.status==="finished");let s=0,r=0;return t.forEach(i=>{s+=i.lastSeen-i.startTime,r+=i.detections.length}),{totalTracks:t.length,activeTracks:e.length,lostTracks:o.length,finishedTracks:n.length,avgTrackDuration:t.length>0?s/t.length:0,avgDetectionsPerTrack:t.length>0?r/t.length:0}}isPointInTrack(t,e,o){const n=this.getTrack(o);if(!n)return!1;const[s,r,i,a]=n.bbox;return t>=s&&t<=i&&e>=r&&e<=a}getTrackHistory(t,e=50){const o=this.getTrack(t);return o?o.detections.slice(-e).map(s=>({timeMs:o.startTime,bbox:s.bbox,confidence:s.conf})):[]}predictNextPosition(t){const e=this.getTrack(t);if(!e||e.detections.length<2)return null;const o=e.detections.slice(-2),[n,s]=o,r=s.bbox[0]-n.bbox[0],i=s.bbox[1]-n.bbox[1],a=s.bbox[2]-n.bbox[2],c=s.bbox[3]-n.bbox[3];return[s.bbox[0]+r,s.bbox[1]+i,s.bbox[2]+a,s.bbox[3]+c]}}class I{constructor(t){l(this,"ocrData",null);l(this,"logger");this.logger=t}async loadOCRData(t,e="/"){try{const o=await fetch(`${e}assets/ocr/${t}.ocr.json`);if(!o.ok)throw new Error(`Failed to load OCR data: ${o.status}`);this.ocrData=await o.json(),this.ocrData&&this.logger.info("OCRPrecomputed","OCR data loaded",{videoId:t,tracksCount:Object.keys(this.ocrData.tracks).length,totalCrops:Object.values(this.ocrData.tracks).reduce((n,s)=>n+s.crops.length,0)})}catch(o){throw this.logger.error("OCRPrecomputed","Failed to load OCR data",{error:o,videoId:t}),o}}getCandidatesForCrop(t){var e;if(!this.ocrData)return this.logger.warn("OCRPrecomputed","OCR data not loaded"),[];for(const o of Object.values(this.ocrData.tracks)){const n=o.crops.find(s=>s.cropId===t);if(n)return this.logger.debug("OCRPrecomputed","Found OCR candidates",{cropId:t,candidateCount:n.candidates.length,bestCandidate:((e=n.candidates[0])==null?void 0:e.text)||"none"}),n.candidates}return this.logger.warn("OCRPrecomputed","Crop not found in OCR data",{cropId:t}),[]}getCandidatesForTrack(t){if(!this.ocrData||!this.ocrData.tracks[t])return this.logger.warn("OCRPrecomputed","Track not found in OCR data",{trackId:t}),[];const e=this.ocrData.tracks[t],o=e.crops.map(n=>n.candidates);return this.logger.debug("OCRPrecomputed","Retrieved track candidates",{trackId:t,cropCount:e.crops.length,totalCandidates:o.flat().length}),o}getBestCandidateForCrop(t){const e=this.getCandidatesForCrop(t);return e.length===0?null:e.reduce((o,n)=>n.conf>o.conf?n:o)}getBestCandidateForTrack(t){const e=this.getCandidatesForTrack(t).flat();return e.length===0?null:e.reduce((o,n)=>n.conf>o.conf?n:o)}getOCRData(){return this.ocrData}getTrackIds(){return this.ocrData?Object.keys(this.ocrData.tracks):[]}getCropIdsForTrack(t){return!this.ocrData||!this.ocrData.tracks[t]?[]:this.ocrData.tracks[t].crops.map(e=>e.cropId)}getStatistics(){if(!this.ocrData)return{totalTracks:0,totalCrops:0,totalCandidates:0,avgCandidatesPerCrop:0,avgConfidence:0,language:"unknown"};const t=Object.values(this.ocrData.tracks),e=t.reduce((r,i)=>r+i.crops.length,0),o=t.reduce((r,i)=>r+i.crops.reduce((a,c)=>a+c.candidates.length,0),0),n=t.flatMap(r=>r.crops.flatMap(i=>i.candidates.map(a=>a.conf))),s=n.length>0?n.reduce((r,i)=>r+i,0)/n.length:0;return{totalTracks:t.length,totalCrops:e,totalCandidates:o,avgCandidatesPerCrop:e>0?o/e:0,avgConfidence:s,language:this.ocrData.metadata.language}}simulateOCR(t){const e=[{text:"à¦¸à¦–à§€-à¦¬à¦¯-à¦¯à¦¾à¦¯à¦¼à¦°",conf:.93},{text:"à¦¸à¦–à§€-à¦¬à¦¯-à¦¯à¦¾à¦¯à¦¼à¦¬",conf:.61},{text:"à¦¸à¦–à§€-à¦¬à¦¯-à¦¯à¦¾à¦¯à¦¼à¦°",conf:.45},{text:"à¦¸à¦–à§€-à¦¬à¦¯-à¦¯à¦¾à¦¯à¦¼à¦¬",conf:.32},{text:"à¦¸à¦–à§€-à¦¬à¦¯-à¦¯à¦¾à¦¯à¦¼à¦°",conf:.28}];return this.logger.info("OCRPrecomputed","Simulated OCR processing",{cropId:t.cropId,candidates:e.length,bestText:e[0].text,bestConf:e[0].conf}),e}reset(){this.ocrData=null,this.logger.info("OCRPrecomputed","OCR data reset")}}class w{constructor(t){l(this,"logger");this.logger=t}vote(t){if(t.length===0)return this.logger.warn("Voter","No candidates provided for voting"),this.createEmptyResult();const e=t.flat();if(e.length===0)return this.logger.warn("Voter","No candidates found in input"),this.createEmptyResult();const o=new Map;e.forEach(a=>{o.has(a.text)||o.set(a.text,{count:0,confidences:[],candidates:[]});const c=o.get(a.text);c.count++,c.confidences.push(a.conf),c.candidates.push(a)});const n=Array.from(o.entries()).map(([a,c])=>({text:a,count:c.count,avgConfidence:c.confidences.reduce((h,d)=>h+d,0)/c.confidences.length,maxConfidence:Math.max(...c.confidences),totalConfidence:c.confidences.reduce((h,d)=>h+d,0)}));n.sort((a,c)=>c.count-a.count);let s,r;if(n.length===1||n[0].count>n[1].count)s=n[0],r="frequency";else{const a=n.filter(c=>c.count===n[0].count);a.sort((c,h)=>h.avgConfidence-c.avgConfidence),a.length===1||a[0].avgConfidence>a[1].avgConfidence?(s=a[0],r="confidence"):(a.sort((c,h)=>h.maxConfidence-c.maxConfidence),s=a[0],r="tiebreak")}const i={winner:s.text,confidence:s.avgConfidence,votes:Object.fromEntries(n.map(a=>[a.text,a.count])),method:r,candidates:n.map(a=>({text:a.text,count:a.count,avgConfidence:a.avgConfidence,maxConfidence:a.maxConfidence}))};return this.logger.info("Voter","Voting completed",{winner:s.text,confidence:s.avgConfidence,method:r,totalCandidates:e.length,uniqueTexts:n.length,cropCount:t.length}),i}voteSingleCrop(t){return this.vote([t])}getVotingStatistics(t){const e=t.flat();if(e.length===0)return{totalCrops:0,totalCandidates:0,uniqueTexts:0,avgCandidatesPerCrop:0,confidenceRange:{min:0,max:0,avg:0}};const o=new Set(e.map(s=>s.text)).size,n=e.map(s=>s.conf);return{totalCrops:t.length,totalCandidates:e.length,uniqueTexts:o,avgCandidatesPerCrop:t.length>0?e.length/t.length:0,confidenceRange:{min:Math.min(...n),max:Math.max(...n),avg:n.reduce((s,r)=>s+r,0)/n.length}}}createEmptyResult(){return{winner:"",confidence:0,votes:{},method:"frequency",candidates:[]}}simulateVote(t){const e=[{text:t,count:5,avgConfidence:.87,maxConfidence:.93},{text:t.replace("à¦°","à¦¬"),count:2,avgConfidence:.61,maxConfidence:.68},{text:t.replace("à¦¯à¦¾à¦¯à¦¼à¦°","à¦¯à¦¾à¦¯à¦¼à¦¬"),count:1,avgConfidence:.45,maxConfidence:.45}];return{winner:t,confidence:.87,votes:Object.fromEntries(e.map(o=>[o.text,o.count])),method:"frequency",candidates:e}}}class O{constructor(t){l(this,"polygon",null);l(this,"logger");l(this,"canvas",null);l(this,"ctx",null);l(this,"isDrawing",!1);l(this,"tempPoints",[]);this.logger=t}setCanvas(t){this.canvas=t,this.ctx=t.getContext("2d"),this.logger.info("ROI","Canvas set",{width:t.width,height:t.height})}startDrawing(){if(!this.canvas){this.logger.error("ROI","Cannot start drawing without canvas");return}this.isDrawing=!0,this.tempPoints=[],this.logger.info("ROI","Started drawing ROI")}addPoint(t,e){this.isDrawing&&(this.tempPoints.push({x:t,y:e}),this.logger.debug("ROI","Added point",{x:t,y:e,totalPoints:this.tempPoints.length}),this.drawTempPolygon())}finishDrawing(){if(!this.isDrawing||this.tempPoints.length<3){this.logger.warn("ROI","Cannot finish ROI with less than 3 points");return}this.polygon={points:[...this.tempPoints],active:!0,name:`ROI_${Date.now()}`},this.isDrawing=!1,this.tempPoints=[],this.logger.info("ROI","ROI created",{pointCount:this.polygon.points.length,name:this.polygon.name})}cancelDrawing(){this.isDrawing=!1,this.tempPoints=[],this.logger.info("ROI","Drawing cancelled")}drawTempPolygon(){if(!(!this.ctx||this.tempPoints.length===0)){this.ctx.save(),this.ctx.strokeStyle="rgba(59, 130, 246, 0.8)",this.ctx.lineWidth=2,this.ctx.setLineDash([5,5]),this.ctx.beginPath(),this.ctx.moveTo(this.tempPoints[0].x,this.tempPoints[0].y);for(let t=1;t<this.tempPoints.length;t++)this.ctx.lineTo(this.tempPoints[t].x,this.tempPoints[t].y);this.tempPoints.length>2&&(this.ctx.closePath(),this.ctx.fillStyle="rgba(59, 130, 246, 0.1)",this.ctx.fill()),this.ctx.stroke(),this.ctx.fillStyle="rgba(59, 130, 246, 1)",this.tempPoints.forEach(t=>{this.ctx.beginPath(),this.ctx.arc(t.x,t.y,4,0,Math.PI*2),this.ctx.fill()}),this.ctx.restore()}}drawROI(t){const e=t||this.ctx;if(!(!e||!this.polygon||!this.polygon.active)){e.save(),e.strokeStyle="rgba(59, 130, 246, 0.8)",e.lineWidth=2,e.setLineDash([5,5]),e.beginPath(),e.moveTo(this.polygon.points[0].x,this.polygon.points[0].y);for(let o=1;o<this.polygon.points.length;o++)e.lineTo(this.polygon.points[o].x,this.polygon.points[o].y);e.closePath(),e.fillStyle="rgba(59, 130, 246, 0.1)",e.fill(),e.stroke(),e.fillStyle="rgba(59, 130, 246, 1)",this.polygon.points.forEach(o=>{e.beginPath(),e.arc(o.x,o.y,3,0,Math.PI*2),e.fill()}),e.restore()}}isPointInside(t,e){return!this.polygon||!this.polygon.active?!0:this.pointInPolygon(t,e,this.polygon.points)}isBBoxInside(t,e=.5){if(!this.polygon||!this.polygon.active)return!0;const[o,n,s,r]=t,i=(o+s)/2,a=(n+r)/2;return e===.5?this.isPointInside(i,a):[{x:o,y:n},{x:s,y:n},{x:s,y:r},{x:o,y:r}].filter(d=>this.isPointInside(d.x,d.y)).length/4>=e}pointInPolygon(t,e,o){let n=!1;for(let s=0,r=o.length-1;s<o.length;r=s++){const i=o[s].x,a=o[s].y,c=o[r].x,h=o[r].y;a>e!=h>e&&t<(c-i)*(e-a)/(h-a)+i&&(n=!n)}return n}setPolygon(t){this.polygon=t,this.logger.info("ROI","Polygon set",{pointCount:t.points.length,active:t.active,name:t.name})}getPolygon(){return this.polygon}clearROI(){this.polygon=null,this.logger.info("ROI","ROI cleared")}toggleActive(){this.polygon&&(this.polygon.active=!this.polygon.active,this.logger.info("ROI","ROI toggled",{active:this.polygon.active}))}saveToJSON(){return this.polygon?JSON.stringify(this.polygon,null,2):(this.logger.warn("ROI","No polygon to save"),"{}")}loadFromJSON(t){try{const e=JSON.parse(t);if(!e.points||!Array.isArray(e.points))throw new Error("Invalid polygon format");this.polygon=e,this.logger.info("ROI","Polygon loaded from JSON",{pointCount:e.points.length,active:e.active})}catch(e){throw this.logger.error("ROI","Failed to load polygon from JSON",{error:e}),e}}scalePolygon(t,e){this.polygon&&(this.polygon.points=this.polygon.points.map(o=>({x:o.x*t,y:o.y*e})),this.logger.info("ROI","Polygon scaled",{scaleX:t,scaleY:e}))}getBounds(){if(!this.polygon||this.polygon.points.length===0)return null;let t=1/0,e=1/0,o=-1/0,n=-1/0;return this.polygon.points.forEach(s=>{t=Math.min(t,s.x),e=Math.min(e,s.y),o=Math.max(o,s.x),n=Math.max(n,s.y)}),{minX:t,minY:e,maxX:o,maxY:n}}getArea(){if(!this.polygon||this.polygon.points.length<3)return 0;let t=0;const e=this.polygon.points;for(let o=0;o<e.length;o++){const n=(o+1)%e.length;t+=e[o].x*e[n].y,t-=e[n].x*e[o].y}return Math.abs(t/2)}isValid(){if(!this.polygon||this.polygon.points.length<3)return!1;const t=this.polygon.points;for(let e=0;e<t.length;e++){const o=t[e],n=t[(e+1)%t.length];for(let s=e+2;s<t.length;s++){if(e===0&&s===t.length-1)continue;const r=t[s],i=t[(s+1)%t.length];if(this.linesIntersect(o,n,r,i))return!1}}return!0}linesIntersect(t,e,o,n){const s=(r,i,a)=>(a.y-r.y)*(i.x-r.x)>(i.y-r.y)*(a.x-r.x);return s(t,o,n)!==s(e,o,n)&&s(t,e,o)!==s(t,e,n)}}export{T as D,I as O,O as R,v as T,w as V,P as a};
//# sourceMappingURL=pipeline-MDk2j22w.js.map

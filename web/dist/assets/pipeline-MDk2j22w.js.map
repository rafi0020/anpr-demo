{"version":3,"file":"pipeline-MDk2j22w.js","sources":["../../src/pipeline/TraceLogger.ts","../../src/pipeline/DetectorPrecomputed.ts","../../src/pipeline/TrackerSimple.ts","../../src/pipeline/OCRPrecomputed.ts","../../src/pipeline/Voter.ts","../../src/pipeline/ROI.ts"],"sourcesContent":["import { TraceLog } from '@/types';\r\n\r\nexport class TraceLogger {\r\n  private logs: TraceLog[] = [];\r\n  private maxLogs: number = 1000;\r\n  private listeners: Set<(log: TraceLog) => void> = new Set();\r\n\r\n  constructor(maxLogs: number = 1000) {\r\n    this.maxLogs = maxLogs;\r\n  }\r\n\r\n  log(module: string, message: string, data: any = {}, level: TraceLog['level'] = 'info'): void {\r\n    const log: TraceLog = {\r\n      timestamp: Date.now(),\r\n      module,\r\n      message,\r\n      data,\r\n      level,\r\n    };\r\n\r\n    this.logs.push(log);\r\n\r\n    // Keep logs under max limit\r\n    if (this.logs.length > this.maxLogs) {\r\n      this.logs.shift();\r\n    }\r\n\r\n    // Notify listeners\r\n    this.listeners.forEach(listener => listener(log));\r\n\r\n    // Console output for debugging\r\n    const consoleMethod = level === 'error' ? console.error : \r\n                         level === 'warn' ? console.warn : \r\n                         level === 'debug' ? console.debug : \r\n                         console.log;\r\n    \r\n    consoleMethod(`[${module}] ${message}`, data);\r\n  }\r\n\r\n  info(module: string, message: string, data: any = {}): void {\r\n    this.log(module, message, data, 'info');\r\n  }\r\n\r\n  warn(module: string, message: string, data: any = {}): void {\r\n    this.log(module, message, data, 'warn');\r\n  }\r\n\r\n  error(module: string, message: string, data: any = {}): void {\r\n    this.log(module, message, data, 'error');\r\n  }\r\n\r\n  debug(module: string, message: string, data: any = {}): void {\r\n    this.log(module, message, data, 'debug');\r\n  }\r\n\r\n  getLogs(filter?: { module?: string; level?: TraceLog['level'] }): TraceLog[] {\r\n    if (!filter) return [...this.logs];\r\n\r\n    return this.logs.filter(log => {\r\n      if (filter.module && log.module !== filter.module) return false;\r\n      if (filter.level && log.level !== filter.level) return false;\r\n      return true;\r\n    });\r\n  }\r\n\r\n  getRecentLogs(count: number = 50): TraceLog[] {\r\n    return this.logs.slice(-count);\r\n  }\r\n\r\n  clearLogs(): void {\r\n    this.logs = [];\r\n  }\r\n\r\n  subscribe(listener: (log: TraceLog) => void): () => void {\r\n    this.listeners.add(listener);\r\n    return () => this.listeners.delete(listener);\r\n  }\r\n\r\n  exportLogs(): string {\r\n    return JSON.stringify(this.logs, null, 2);\r\n  }\r\n\r\n  exportReport(): {\r\n    summary: {\r\n      totalLogs: number;\r\n      byLevel: Record<TraceLog['level'], number>;\r\n      byModule: Record<string, number>;\r\n    };\r\n    logs: TraceLog[];\r\n    timeline: {\r\n      startTime: number;\r\n      endTime: number;\r\n      duration: number;\r\n    };\r\n  } {\r\n    const byLevel: Record<TraceLog['level'], number> = {\r\n      info: 0,\r\n      warn: 0,\r\n      error: 0,\r\n      debug: 0,\r\n    };\r\n\r\n    const byModule: Record<string, number> = {};\r\n\r\n    this.logs.forEach(log => {\r\n      byLevel[log.level]++;\r\n      byModule[log.module] = (byModule[log.module] || 0) + 1;\r\n    });\r\n\r\n    const startTime = this.logs[0]?.timestamp || 0;\r\n    const endTime = this.logs[this.logs.length - 1]?.timestamp || 0;\r\n\r\n    return {\r\n      summary: {\r\n        totalLogs: this.logs.length,\r\n        byLevel,\r\n        byModule,\r\n      },\r\n      logs: [...this.logs],\r\n      timeline: {\r\n        startTime,\r\n        endTime,\r\n        duration: endTime - startTime,\r\n      },\r\n    };\r\n  }\r\n\r\n  // Format log for display\r\n  formatLog(log: TraceLog): string {\r\n    const date = new Date(log.timestamp);\r\n    const time = date.toLocaleTimeString('en-US', { \r\n      hour12: false, \r\n      hour: '2-digit', \r\n      minute: '2-digit', \r\n      second: '2-digit'\r\n    });\r\n    const ms = String(log.timestamp % 1000).padStart(3, '0');\r\n    \r\n    const levelEmoji = {\r\n      info: '‚ÑπÔ∏è',\r\n      warn: '‚ö†Ô∏è',\r\n      error: '‚ùå',\r\n      debug: 'üîç',\r\n    };\r\n\r\n    return `${time}.${ms} ${levelEmoji[log.level]} [${log.module}] ${log.message}`;\r\n  }\r\n\r\n  // Get logs grouped by module\r\n  getLogsByModule(): Map<string, TraceLog[]> {\r\n    const grouped = new Map<string, TraceLog[]>();\r\n    \r\n    this.logs.forEach(log => {\r\n      if (!grouped.has(log.module)) {\r\n        grouped.set(log.module, []);\r\n      }\r\n      grouped.get(log.module)!.push(log);\r\n    });\r\n\r\n    return grouped;\r\n  }\r\n\r\n  // Get performance metrics\r\n  getPerformanceMetrics(): {\r\n    modules: Array<{\r\n      name: string;\r\n      count: number;\r\n      duration: number;\r\n      avgDuration: number;\r\n    }>;\r\n    totalDuration: number;\r\n  } {\r\n    const modules = new Map<string, { count: number; startTime: number; totalDuration: number }>();\r\n    \r\n    this.logs.forEach((log, index) => {\r\n      if (!modules.has(log.module)) {\r\n        modules.set(log.module, { count: 0, startTime: log.timestamp, totalDuration: 0 });\r\n      }\r\n      \r\n      const moduleData = modules.get(log.module)!;\r\n      moduleData.count++;\r\n      \r\n      // Calculate duration to next log\r\n      if (index < this.logs.length - 1) {\r\n        const nextLog = this.logs[index + 1];\r\n        const duration = nextLog.timestamp - log.timestamp;\r\n        moduleData.totalDuration += duration;\r\n      }\r\n    });\r\n\r\n    const moduleMetrics = Array.from(modules.entries()).map(([name, data]) => ({\r\n      name,\r\n      count: data.count,\r\n      duration: data.totalDuration,\r\n      avgDuration: data.totalDuration / data.count,\r\n    }));\r\n\r\n    const totalDuration = this.logs.length > 0 \r\n      ? this.logs[this.logs.length - 1].timestamp - this.logs[0].timestamp \r\n      : 0;\r\n\r\n    return {\r\n      modules: moduleMetrics,\r\n      totalDuration,\r\n    };\r\n  }\r\n}\r\n\r\n// Singleton instance for global access\r\nexport const globalLogger = new TraceLogger();\r\n","import { Detection, DetectionData, Frame } from '@/types';\r\nimport { TraceLogger } from './TraceLogger';\r\n\r\nexport class DetectorPrecomputed {\r\n  private detectionData: DetectionData | null = null;\r\n  private logger: TraceLogger;\r\n  private frameIndex: Map<number, Frame> = new Map();\r\n  private timeTolerance: number = 100; // ms tolerance for frame matching\r\n\r\n  constructor(logger: TraceLogger) {\r\n    this.logger = logger;\r\n  }\r\n\r\n  async loadDetections(url: string): Promise<void> {\r\n    try {\r\n      this.logger.info('DetectorPrecomputed', 'Loading detections', { url });\r\n      \r\n      const response = await fetch(url);\r\n      if (!response.ok) {\r\n        throw new Error(`Failed to load detections: ${response.statusText}`);\r\n      }\r\n\r\n      this.detectionData = await response.json();\r\n      \r\n      // Build frame index for faster lookup\r\n      this.buildFrameIndex();\r\n      \r\n      this.logger.info('DetectorPrecomputed', 'Detections loaded', {\r\n        videoId: this.detectionData?.videoId,\r\n        frameCount: this.detectionData?.frames.length,\r\n        fps: this.detectionData?.fps\r\n      });\r\n    } catch (error) {\r\n      this.logger.error('DetectorPrecomputed', 'Failed to load detections', { error });\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  private buildFrameIndex(): void {\r\n    if (!this.detectionData) return;\r\n\r\n    this.frameIndex.clear();\r\n    this.detectionData.frames.forEach(frame => {\r\n      // Index by time bucket (rounded to nearest 100ms)\r\n      const bucket = Math.round(frame.timeMs / 100) * 100;\r\n      this.frameIndex.set(bucket, frame);\r\n    });\r\n\r\n    this.logger.debug('DetectorPrecomputed', 'Frame index built', {\r\n      buckets: this.frameIndex.size\r\n    });\r\n  }\r\n\r\n  getDetections(timeMs: number): Detection[] {\r\n    if (!this.detectionData) {\r\n      this.logger.warn('DetectorPrecomputed', 'No detection data loaded');\r\n      return [];\r\n    }\r\n\r\n    // Find nearest frame\r\n    const frame = this.findNearestFrame(timeMs);\r\n    \r\n    if (!frame) {\r\n      this.logger.debug('DetectorPrecomputed', 'No frame found', { timeMs });\r\n      return [];\r\n    }\r\n\r\n    this.logger.debug('DetectorPrecomputed', 'Detections retrieved', {\r\n      timeMs,\r\n      frameTime: frame.timeMs,\r\n      detectionCount: frame.detections.length\r\n    });\r\n\r\n    return frame.detections;\r\n  }\r\n\r\n  private findNearestFrame(timeMs: number): Frame | null {\r\n    if (!this.detectionData) return null;\r\n\r\n    // Try exact match first\r\n    const exactFrame = this.detectionData.frames.find(f => f.timeMs === timeMs);\r\n    if (exactFrame) return exactFrame;\r\n\r\n    // Try bucket match\r\n    const bucket = Math.round(timeMs / 100) * 100;\r\n    const bucketFrame = this.frameIndex.get(bucket);\r\n    if (bucketFrame && Math.abs(bucketFrame.timeMs - timeMs) <= this.timeTolerance) {\r\n      return bucketFrame;\r\n    }\r\n\r\n    // Find nearest frame within tolerance\r\n    let nearestFrame: Frame | null = null;\r\n    let minDiff = Infinity;\r\n\r\n    for (const frame of this.detectionData.frames) {\r\n      const diff = Math.abs(frame.timeMs - timeMs);\r\n      if (diff <= this.timeTolerance && diff < minDiff) {\r\n        minDiff = diff;\r\n        nearestFrame = frame;\r\n      }\r\n    }\r\n\r\n    return nearestFrame;\r\n  }\r\n\r\n  getFrameAtTime(timeMs: number): Frame | null {\r\n    return this.findNearestFrame(timeMs);\r\n  }\r\n\r\n  getPlateDetections(timeMs: number): Detection[] {\r\n    const detections = this.getDetections(timeMs);\r\n    return detections.filter(d => d.type === 'plate');\r\n  }\r\n\r\n  getVehicleDetections(timeMs: number): Detection[] {\r\n    const detections = this.getDetections(timeMs);\r\n    return detections.filter(d => d.type === 'vehicle');\r\n  }\r\n\r\n  getDetectionRange(startMs: number, endMs: number): Frame[] {\r\n    if (!this.detectionData) return [];\r\n\r\n    return this.detectionData.frames.filter(\r\n      frame => frame.timeMs >= startMs && frame.timeMs <= endMs\r\n    );\r\n  }\r\n\r\n  interpolateDetections(timeMs: number): Detection[] {\r\n    if (!this.detectionData) return [];\r\n\r\n    // Find frames before and after\r\n    const frames = this.detectionData.frames;\r\n    let frameBefore: Frame | null = null;\r\n    let frameAfter: Frame | null = null;\r\n\r\n    for (let i = 0; i < frames.length; i++) {\r\n      if (frames[i].timeMs <= timeMs) {\r\n        frameBefore = frames[i];\r\n      }\r\n      if (frames[i].timeMs >= timeMs && !frameAfter) {\r\n        frameAfter = frames[i];\r\n        break;\r\n      }\r\n    }\r\n\r\n    // If we only have one frame or exact match, return as is\r\n    if (!frameBefore || !frameAfter || frameBefore === frameAfter) {\r\n      return this.getDetections(timeMs);\r\n    }\r\n\r\n    // Interpolate between frames\r\n    const alpha = (timeMs - frameBefore.timeMs) / (frameAfter.timeMs - frameBefore.timeMs);\r\n    const interpolated: Detection[] = [];\r\n\r\n    // Match detections by trackId\r\n    frameBefore.detections.forEach(detBefore => {\r\n      const detAfter = frameAfter.detections.find(\r\n        d => d.trackId === detBefore.trackId && d.type === detBefore.type\r\n      );\r\n\r\n      if (detAfter) {\r\n        // Interpolate bbox\r\n        const bbox: [number, number, number, number] = [\r\n          Math.round(detBefore.bbox[0] + (detAfter.bbox[0] - detBefore.bbox[0]) * alpha),\r\n          Math.round(detBefore.bbox[1] + (detAfter.bbox[1] - detBefore.bbox[1]) * alpha),\r\n          Math.round(detBefore.bbox[2] + (detAfter.bbox[2] - detBefore.bbox[2]) * alpha),\r\n          Math.round(detBefore.bbox[3] + (detAfter.bbox[3] - detBefore.bbox[3]) * alpha),\r\n        ];\r\n\r\n        // Interpolate confidence\r\n        const conf = detBefore.conf + (detAfter.conf - detBefore.conf) * alpha;\r\n\r\n        interpolated.push({\r\n          type: detBefore.type,\r\n          bbox,\r\n          conf,\r\n          trackId: detBefore.trackId\r\n        });\r\n      }\r\n    });\r\n\r\n    this.logger.debug('DetectorPrecomputed', 'Interpolated detections', {\r\n      timeMs,\r\n      frameBefore: frameBefore.timeMs,\r\n      frameAfter: frameAfter.timeMs,\r\n      alpha,\r\n      interpolatedCount: interpolated.length\r\n    });\r\n\r\n    return interpolated;\r\n  }\r\n\r\n  getMetadata(): DetectionData['metadata'] | null {\r\n    return this.detectionData?.metadata || null;\r\n  }\r\n\r\n  getResolution(): { width: number; height: number } | null {\r\n    return this.detectionData?.resolution || null;\r\n  }\r\n\r\n  getFPS(): number {\r\n    return this.detectionData?.fps || 30;\r\n  }\r\n\r\n  isLoaded(): boolean {\r\n    return this.detectionData !== null;\r\n  }\r\n\r\n  clear(): void {\r\n    this.detectionData = null;\r\n    this.frameIndex.clear();\r\n    this.logger.info('DetectorPrecomputed', 'Cleared detection data');\r\n  }\r\n\r\n  // Get statistics about detections\r\n  getStatistics(): {\r\n    totalFrames: number;\r\n    totalDetections: number;\r\n    plateDetections: number;\r\n    vehicleDetections: number;\r\n    timeRange: { start: number; end: number };\r\n    avgDetectionsPerFrame: number;\r\n  } | null {\r\n    if (!this.detectionData) return null;\r\n\r\n    let totalDetections = 0;\r\n    let plateDetections = 0;\r\n    let vehicleDetections = 0;\r\n\r\n    this.detectionData.frames.forEach(frame => {\r\n      totalDetections += frame.detections.length;\r\n      plateDetections += frame.detections.filter(d => d.type === 'plate').length;\r\n      vehicleDetections += frame.detections.filter(d => d.type === 'vehicle').length;\r\n    });\r\n\r\n    const frames = this.detectionData.frames;\r\n    const timeRange = frames.length > 0 \r\n      ? { start: frames[0].timeMs, end: frames[frames.length - 1].timeMs }\r\n      : { start: 0, end: 0 };\r\n\r\n    return {\r\n      totalFrames: frames.length,\r\n      totalDetections,\r\n      plateDetections,\r\n      vehicleDetections,\r\n      timeRange,\r\n      avgDetectionsPerFrame: frames.length > 0 ? totalDetections / frames.length : 0\r\n    };\r\n  }\r\n}\r\n","import { Detection, Track, BBoxArray } from '@/types';\r\nimport { TraceLogger } from './TraceLogger';\r\n\r\nexport class TrackerSimple {\r\n  private tracks: Map<string, Track> = new Map();\r\n  private nextTrackId: number = 1;\r\n  private logger: TraceLogger;\r\n  \r\n  // Tracking parameters\r\n  private iouThreshold: number = 0.3;\r\n  private maxLostFrames: number = 10;\r\n  private minDetections: number = 3;\r\n  private frameCount: number = 0;\r\n\r\n  constructor(logger: TraceLogger, config?: {\r\n    iouThreshold?: number;\r\n    maxLostFrames?: number;\r\n    minDetections?: number;\r\n  }) {\r\n    this.logger = logger;\r\n    this.iouThreshold = config?.iouThreshold ?? this.iouThreshold;\r\n    this.maxLostFrames = config?.maxLostFrames ?? this.maxLostFrames;\r\n    this.minDetections = config?.minDetections ?? this.minDetections;\r\n  }\r\n\r\n  update(detections: Detection[], timeMs: number): Track[] {\r\n    this.frameCount++;\r\n    \r\n    this.logger.debug('TrackerSimple', 'Update cycle', {\r\n      frameCount: this.frameCount,\r\n      timeMs,\r\n      detectionCount: detections.length,\r\n      activeTrackCount: this.getActiveTracks().length\r\n    });\r\n\r\n    // Update existing tracks to 'lost' if not matched\r\n    this.tracks.forEach(track => {\r\n      if (track.status === 'active') {\r\n        track.status = 'lost';\r\n      }\r\n    });\r\n\r\n    // Match detections to existing tracks\r\n    const unmatchedDetections: Detection[] = [];\r\n    \r\n    for (const detection of detections) {\r\n      if (detection.type !== 'plate') continue;\r\n      \r\n      let bestMatch: Track | null = null;\r\n      let bestIOU = 0;\r\n\r\n      // Find best matching track\r\n      this.tracks.forEach(track => {\r\n        if (track.status === 'finished') return;\r\n        \r\n        const iou = this.calculateIOU(detection.bbox, track.bbox);\r\n        if (iou > this.iouThreshold && iou > bestIOU) {\r\n          bestIOU = iou;\r\n          bestMatch = track;\r\n        }\r\n      });\r\n\r\n      if (bestMatch !== null) {\r\n        // Update existing track\r\n        this.updateTrack(bestMatch, detection, timeMs);\r\n        \r\n        // Assign trackId to detection\r\n        detection.trackId = (bestMatch as Track).id;\r\n        \r\n        this.logger.debug('TrackerSimple', 'Matched detection to track', {\r\n          trackId: (bestMatch as Track).id,\r\n          iou: bestIOU,\r\n          confidence: detection.conf\r\n        });\r\n      } else {\r\n        unmatchedDetections.push(detection);\r\n      }\r\n    }\r\n\r\n    // Create new tracks for unmatched detections\r\n    for (const detection of unmatchedDetections) {\r\n      const newTrack = this.createTrack(detection, timeMs);\r\n      detection.trackId = newTrack.id;\r\n      \r\n      this.logger.info('TrackerSimple', 'Created new track', {\r\n        trackId: newTrack.id,\r\n        bbox: detection.bbox,\r\n        confidence: detection.conf\r\n      });\r\n    }\r\n\r\n    // Handle lost tracks\r\n    this.handleLostTracks(timeMs);\r\n\r\n    // Return active tracks\r\n    return this.getActiveTracks();\r\n  }\r\n\r\n  private createTrack(detection: Detection, timeMs: number): Track {\r\n    const track: Track = {\r\n      id: String(this.nextTrackId++),\r\n      status: 'active',\r\n      startTime: timeMs,\r\n      lastSeen: timeMs,\r\n      detections: [detection],\r\n      bbox: [...detection.bbox] as BBoxArray,\r\n      confidence: detection.conf\r\n    };\r\n\r\n    this.tracks.set(String(track.id), track);\r\n    return track;\r\n  }\r\n\r\n  private updateTrack(track: Track, detection: Detection, timeMs: number): void {\r\n    track.status = 'active';\r\n    track.lastSeen = timeMs;\r\n    track.detections.push(detection);\r\n    track.bbox = [...detection.bbox] as BBoxArray;\r\n    track.confidence = (track.confidence * 0.7 + detection.conf * 0.3); // Weighted average\r\n  }\r\n\r\n  private handleLostTracks(timeMs: number): void {\r\n    const tracksToFinish: string[] = [];\r\n\r\n    this.tracks.forEach((track, trackId) => {\r\n      if (track.status === 'lost') {\r\n        const framesLost = Math.round((timeMs - track.lastSeen) / 33); // Assuming ~30fps\r\n        \r\n        if (framesLost > this.maxLostFrames) {\r\n          // Mark track as finished if lost for too long\r\n          track.status = 'finished';\r\n          tracksToFinish.push(trackId);\r\n          \r\n          this.logger.info('TrackerSimple', 'Track finished', {\r\n            trackId: track.id,\r\n            duration: timeMs - track.startTime,\r\n            detectionCount: track.detections.length\r\n          });\r\n        }\r\n      }\r\n    });\r\n\r\n    // Clean up old finished tracks (keep last 10 for reference)\r\n    const finishedTracks = Array.from(this.tracks.values())\r\n      .filter(t => t.status === 'finished')\r\n      .sort((a, b) => b.lastSeen - a.lastSeen);\r\n    \r\n    if (finishedTracks.length > 10) {\r\n      finishedTracks.slice(10).forEach(track => {\r\n        this.tracks.delete(String(track.id));\r\n        this.logger.debug('TrackerSimple', 'Removed old track', { trackId: track.id });\r\n      });\r\n    }\r\n  }\r\n\r\n  private calculateIOU(bbox1: BBoxArray, bbox2: BBoxArray): number {\r\n    const [x1_1, y1_1, x2_1, y2_1] = bbox1;\r\n    const [x1_2, y1_2, x2_2, y2_2] = bbox2;\r\n\r\n    // Calculate intersection\r\n    const xLeft = Math.max(x1_1, x1_2);\r\n    const yTop = Math.max(y1_1, y1_2);\r\n    const xRight = Math.min(x2_1, x2_2);\r\n    const yBottom = Math.min(y2_1, y2_2);\r\n\r\n    if (xRight < xLeft || yBottom < yTop) {\r\n      return 0; // No intersection\r\n    }\r\n\r\n    const intersectionArea = (xRight - xLeft) * (yBottom - yTop);\r\n\r\n    // Calculate union\r\n    const area1 = (x2_1 - x1_1) * (y2_1 - y1_1);\r\n    const area2 = (x2_2 - x1_2) * (y2_2 - y1_2);\r\n    const unionArea = area1 + area2 - intersectionArea;\r\n\r\n    return intersectionArea / unionArea;\r\n  }\r\n\r\n  getTrack(trackId: string | number): Track | null {\r\n    return this.tracks.get(String(trackId)) || null;\r\n  }\r\n\r\n  getActiveTracks(): Track[] {\r\n    return Array.from(this.tracks.values()).filter(t => t.status === 'active');\r\n  }\r\n\r\n  getLostTracks(): Track[] {\r\n    return Array.from(this.tracks.values()).filter(t => t.status === 'lost');\r\n  }\r\n\r\n  getFinishedTracks(): Track[] {\r\n    return Array.from(this.tracks.values()).filter(t => t.status === 'finished');\r\n  }\r\n\r\n  getAllTracks(): Track[] {\r\n    return Array.from(this.tracks.values());\r\n  }\r\n\r\n  reset(): void {\r\n    this.tracks.clear();\r\n    this.nextTrackId = 1;\r\n    this.frameCount = 0;\r\n    this.logger.info('TrackerSimple', 'Tracker reset');\r\n  }\r\n\r\n  // Get track statistics\r\n  getStatistics(): {\r\n    totalTracks: number;\r\n    activeTracks: number;\r\n    lostTracks: number;\r\n    finishedTracks: number;\r\n    avgTrackDuration: number;\r\n    avgDetectionsPerTrack: number;\r\n  } {\r\n    const tracks = Array.from(this.tracks.values());\r\n    const activeTracks = tracks.filter(t => t.status === 'active');\r\n    const lostTracks = tracks.filter(t => t.status === 'lost');\r\n    const finishedTracks = tracks.filter(t => t.status === 'finished');\r\n\r\n    let totalDuration = 0;\r\n    let totalDetections = 0;\r\n\r\n    tracks.forEach(track => {\r\n      totalDuration += track.lastSeen - track.startTime;\r\n      totalDetections += track.detections.length;\r\n    });\r\n\r\n    return {\r\n      totalTracks: tracks.length,\r\n      activeTracks: activeTracks.length,\r\n      lostTracks: lostTracks.length,\r\n      finishedTracks: finishedTracks.length,\r\n      avgTrackDuration: tracks.length > 0 ? totalDuration / tracks.length : 0,\r\n      avgDetectionsPerTrack: tracks.length > 0 ? totalDetections / tracks.length : 0\r\n    };\r\n  }\r\n\r\n  // Check if a point is inside a track's bounding box\r\n  isPointInTrack(x: number, y: number, trackId: string | number): boolean {\r\n    const track = this.getTrack(trackId);\r\n    if (!track) return false;\r\n\r\n    const [x1, y1, x2, y2] = track.bbox;\r\n    return x >= x1 && x <= x2 && y >= y1 && y <= y2;\r\n  }\r\n\r\n  // Get track history for visualization\r\n  getTrackHistory(trackId: string | number, maxPoints: number = 50): Array<{\r\n    timeMs: number;\r\n    bbox: BBoxArray;\r\n    confidence: number;\r\n  }> {\r\n    const track = this.getTrack(trackId);\r\n    if (!track) return [];\r\n\r\n    const history = track.detections.slice(-maxPoints).map(det => ({\r\n      timeMs: track.startTime, // Note: we don't store individual detection times\r\n      bbox: det.bbox,\r\n      confidence: det.conf\r\n    }));\r\n\r\n    return history;\r\n  }\r\n\r\n  // Predict next position (simple linear extrapolation)\r\n  predictNextPosition(trackId: string | number): BBoxArray | null {\r\n    const track = this.getTrack(trackId);\r\n    if (!track || track.detections.length < 2) return null;\r\n\r\n    const recent = track.detections.slice(-2);\r\n    const [prev, curr] = recent;\r\n\r\n    // Calculate velocity\r\n    const vx1 = curr.bbox[0] - prev.bbox[0];\r\n    const vy1 = curr.bbox[1] - prev.bbox[1];\r\n    const vx2 = curr.bbox[2] - prev.bbox[2];\r\n    const vy2 = curr.bbox[3] - prev.bbox[3];\r\n\r\n    // Predict next position\r\n    const predicted: BBoxArray = [\r\n      curr.bbox[0] + vx1,\r\n      curr.bbox[1] + vy1,\r\n      curr.bbox[2] + vx2,\r\n      curr.bbox[3] + vy2\r\n    ];\r\n\r\n    return predicted;\r\n  }\r\n}\r\n","import { OCRData, OCRCandidate, CropImage } from '@/types';\r\nimport { TraceLogger } from './TraceLogger';\r\n\r\nexport class OCRPrecomputed {\r\n  private ocrData: OCRData | null = null;\r\n  private logger: TraceLogger;\r\n\r\n  constructor(logger: TraceLogger) {\r\n    this.logger = logger;\r\n  }\r\n\r\n  async loadOCRData(videoId: string, baseUrl: string = '/'): Promise<void> {\r\n    try {\r\n      const response = await fetch(`${baseUrl}assets/ocr/${videoId}.ocr.json`);\r\n      if (!response.ok) {\r\n        throw new Error(`Failed to load OCR data: ${response.status}`);\r\n      }\r\n\r\n      this.ocrData = await response.json();\r\n\r\n      if (this.ocrData) {\r\n        this.logger.info('OCRPrecomputed', 'OCR data loaded', {\r\n          videoId,\r\n          tracksCount: Object.keys(this.ocrData.tracks).length,\r\n          totalCrops: Object.values(this.ocrData.tracks).reduce(\r\n            (sum, track) => sum + track.crops.length, 0\r\n          )\r\n        });\r\n      }\r\n    } catch (error) {\r\n      this.logger.error('OCRPrecomputed', 'Failed to load OCR data', { error, videoId });\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  getCandidatesForCrop(cropId: string): OCRCandidate[] {\r\n    if (!this.ocrData) {\r\n      this.logger.warn('OCRPrecomputed', 'OCR data not loaded');\r\n      return [];\r\n    }\r\n\r\n    // Find the crop in any track\r\n    for (const track of Object.values(this.ocrData.tracks)) {\r\n      const crop = track.crops.find(c => c.cropId === cropId);\r\n      if (crop) {\r\n        this.logger.debug('OCRPrecomputed', 'Found OCR candidates', {\r\n          cropId,\r\n          candidateCount: crop.candidates.length,\r\n          bestCandidate: crop.candidates[0]?.text || 'none'\r\n        });\r\n\r\n        return crop.candidates;\r\n      }\r\n    }\r\n\r\n    this.logger.warn('OCRPrecomputed', 'Crop not found in OCR data', { cropId });\r\n    return [];\r\n  }\r\n\r\n  getCandidatesForTrack(trackId: string): OCRCandidate[][] {\r\n    if (!this.ocrData || !this.ocrData.tracks[trackId]) {\r\n      this.logger.warn('OCRPrecomputed', 'Track not found in OCR data', { trackId });\r\n      return [];\r\n    }\r\n\r\n    const track = this.ocrData.tracks[trackId];\r\n    const candidates = track.crops.map(crop => crop.candidates);\r\n\r\n    this.logger.debug('OCRPrecomputed', 'Retrieved track candidates', {\r\n      trackId,\r\n      cropCount: track.crops.length,\r\n      totalCandidates: candidates.flat().length\r\n    });\r\n\r\n    return candidates;\r\n  }\r\n\r\n  getBestCandidateForCrop(cropId: string): OCRCandidate | null {\r\n    const candidates = this.getCandidatesForCrop(cropId);\r\n    if (candidates.length === 0) return null;\r\n\r\n    // Return candidate with highest confidence\r\n    return candidates.reduce((best, current) =>\r\n      current.conf > best.conf ? current : best\r\n    );\r\n  }\r\n\r\n  getBestCandidateForTrack(trackId: string): OCRCandidate | null {\r\n    const allCandidates = this.getCandidatesForTrack(trackId).flat();\r\n    if (allCandidates.length === 0) return null;\r\n\r\n    // Return candidate with highest confidence across all crops\r\n    return allCandidates.reduce((best, current) =>\r\n      current.conf > best.conf ? current : best\r\n    );\r\n  }\r\n\r\n  getOCRData(): OCRData | null {\r\n    return this.ocrData;\r\n  }\r\n\r\n  getTrackIds(): string[] {\r\n    return this.ocrData ? Object.keys(this.ocrData.tracks) : [];\r\n  }\r\n\r\n  getCropIdsForTrack(trackId: string): string[] {\r\n    if (!this.ocrData || !this.ocrData.tracks[trackId]) {\r\n      return [];\r\n    }\r\n\r\n    return this.ocrData.tracks[trackId].crops.map(crop => crop.cropId);\r\n  }\r\n\r\n  getStatistics(): {\r\n    totalTracks: number;\r\n    totalCrops: number;\r\n    totalCandidates: number;\r\n    avgCandidatesPerCrop: number;\r\n    avgConfidence: number;\r\n    language: string;\r\n  } {\r\n    if (!this.ocrData) {\r\n      return {\r\n        totalTracks: 0,\r\n        totalCrops: 0,\r\n        totalCandidates: 0,\r\n        avgCandidatesPerCrop: 0,\r\n        avgConfidence: 0,\r\n        language: 'unknown'\r\n      };\r\n    }\r\n\r\n    const tracks = Object.values(this.ocrData.tracks);\r\n    const totalCrops = tracks.reduce((sum, track) => sum + track.crops.length, 0);\r\n    const totalCandidates = tracks.reduce(\r\n      (sum, track) => sum + track.crops.reduce((cropSum, crop) => cropSum + crop.candidates.length, 0),\r\n      0\r\n    );\r\n\r\n    const allConfidences = tracks.flatMap(track =>\r\n      track.crops.flatMap(crop => crop.candidates.map(c => c.conf))\r\n    );\r\n\r\n    const avgConfidence = allConfidences.length > 0\r\n      ? allConfidences.reduce((sum, conf) => sum + conf, 0) / allConfidences.length\r\n      : 0;\r\n\r\n    return {\r\n      totalTracks: tracks.length,\r\n      totalCrops,\r\n      totalCandidates,\r\n      avgCandidatesPerCrop: totalCrops > 0 ? totalCandidates / totalCrops : 0,\r\n      avgConfidence,\r\n      language: this.ocrData.metadata.language\r\n    };\r\n  }\r\n\r\n  // Method to simulate OCR processing for new crops (for annotation tool)\r\n  simulateOCR(crop: CropImage): OCRCandidate[] {\r\n    // For demo purposes, return mock candidates\r\n    // In production, this would call actual OCR service\r\n    const mockCandidates: OCRCandidate[] = [\r\n      { text: '‡¶∏‡¶ñ‡ßÄ-‡¶¨‡¶Ø-‡¶Ø‡¶æ‡¶Ø‡¶º‡¶∞', conf: 0.93 },\r\n      { text: '‡¶∏‡¶ñ‡ßÄ-‡¶¨‡¶Ø-‡¶Ø‡¶æ‡¶Ø‡¶º‡¶¨', conf: 0.61 },\r\n      { text: '‡¶∏‡¶ñ‡ßÄ-‡¶¨‡¶Ø-‡¶Ø‡¶æ‡¶Ø‡¶º‡¶∞', conf: 0.45 },\r\n      { text: '‡¶∏‡¶ñ‡ßÄ-‡¶¨‡¶Ø-‡¶Ø‡¶æ‡¶Ø‡¶º‡¶¨', conf: 0.32 },\r\n      { text: '‡¶∏‡¶ñ‡ßÄ-‡¶¨‡¶Ø-‡¶Ø‡¶æ‡¶Ø‡¶º‡¶∞', conf: 0.28 }\r\n    ];\r\n\r\n    this.logger.info('OCRPrecomputed', 'Simulated OCR processing', {\r\n      cropId: crop.cropId,\r\n      candidates: mockCandidates.length,\r\n      bestText: mockCandidates[0].text,\r\n      bestConf: mockCandidates[0].conf\r\n    });\r\n\r\n    return mockCandidates;\r\n  }\r\n\r\n  reset(): void {\r\n    this.ocrData = null;\r\n    this.logger.info('OCRPrecomputed', 'OCR data reset');\r\n  }\r\n}\r\n","import { VoteResult, OCRCandidate } from '@/types';\r\nimport { TraceLogger } from './TraceLogger';\r\n\r\nexport class Voter {\r\n  private logger: TraceLogger;\r\n\r\n  constructor(logger: TraceLogger) {\r\n    this.logger = logger;\r\n  }\r\n\r\n  vote(candidates: OCRCandidate[][]): VoteResult {\r\n    if (candidates.length === 0) {\r\n      this.logger.warn('Voter', 'No candidates provided for voting');\r\n      return this.createEmptyResult();\r\n    }\r\n\r\n    // Flatten all candidates\r\n    const allCandidates = candidates.flat();\r\n\r\n    if (allCandidates.length === 0) {\r\n      this.logger.warn('Voter', 'No candidates found in input');\r\n      return this.createEmptyResult();\r\n    }\r\n\r\n    // Group by text and calculate statistics\r\n    const textGroups = new Map<string, {\r\n      count: number;\r\n      confidences: number[];\r\n      candidates: OCRCandidate[];\r\n    }>();\r\n\r\n    allCandidates.forEach(candidate => {\r\n      if (!textGroups.has(candidate.text)) {\r\n        textGroups.set(candidate.text, {\r\n          count: 0,\r\n          confidences: [],\r\n          candidates: []\r\n        });\r\n      }\r\n\r\n      const group = textGroups.get(candidate.text)!;\r\n      group.count++;\r\n      group.confidences.push(candidate.conf);\r\n      group.candidates.push(candidate);\r\n    });\r\n\r\n    // Convert to array and sort by voting method\r\n    const voteCandidates = Array.from(textGroups.entries()).map(([text, data]) => ({\r\n      text,\r\n      count: data.count,\r\n      avgConfidence: data.confidences.reduce((sum, conf) => sum + conf, 0) / data.confidences.length,\r\n      maxConfidence: Math.max(...data.confidences),\r\n      totalConfidence: data.confidences.reduce((sum, conf) => sum + conf, 0)\r\n    }));\r\n\r\n    // Sort by frequency first (most common)\r\n    voteCandidates.sort((a, b) => b.count - a.count);\r\n\r\n    // Find the winner using the voting algorithm\r\n    let winner: typeof voteCandidates[0];\r\n    let method: 'frequency' | 'confidence' | 'tiebreak';\r\n\r\n    // Check if there's a clear frequency winner\r\n    if (voteCandidates.length === 1 || voteCandidates[0].count > voteCandidates[1].count) {\r\n      winner = voteCandidates[0];\r\n      method = 'frequency';\r\n    } else {\r\n      // Tie in frequency, use confidence tiebreaker\r\n      const tiedCandidates = voteCandidates.filter(c => c.count === voteCandidates[0].count);\r\n\r\n      // Sort tied candidates by average confidence\r\n      tiedCandidates.sort((a, b) => b.avgConfidence - a.avgConfidence);\r\n\r\n      if (tiedCandidates.length === 1 || tiedCandidates[0].avgConfidence > tiedCandidates[1].avgConfidence) {\r\n        winner = tiedCandidates[0];\r\n        method = 'confidence';\r\n      } else {\r\n        // Still tied, use max confidence\r\n        tiedCandidates.sort((a, b) => b.maxConfidence - a.maxConfidence);\r\n        winner = tiedCandidates[0];\r\n        method = 'tiebreak';\r\n      }\r\n    }\r\n\r\n    const result: VoteResult = {\r\n      winner: winner.text,\r\n      confidence: winner.avgConfidence,\r\n      votes: Object.fromEntries(voteCandidates.map(c => [c.text, c.count])),\r\n      method,\r\n      candidates: voteCandidates.map(c => ({\r\n        text: c.text,\r\n        count: c.count,\r\n        avgConfidence: c.avgConfidence,\r\n        maxConfidence: c.maxConfidence\r\n      }))\r\n    };\r\n\r\n    this.logger.info('Voter', 'Voting completed', {\r\n      winner: winner.text,\r\n      confidence: winner.avgConfidence,\r\n      method,\r\n      totalCandidates: allCandidates.length,\r\n      uniqueTexts: voteCandidates.length,\r\n      cropCount: candidates.length\r\n    });\r\n\r\n    return result;\r\n  }\r\n\r\n  voteSingleCrop(candidates: OCRCandidate[]): VoteResult {\r\n    return this.vote([candidates]);\r\n  }\r\n\r\n  getVotingStatistics(candidates: OCRCandidate[][]): {\r\n    totalCrops: number;\r\n    totalCandidates: number;\r\n    uniqueTexts: number;\r\n    avgCandidatesPerCrop: number;\r\n    confidenceRange: { min: number; max: number; avg: number };\r\n  } {\r\n    const allCandidates = candidates.flat();\r\n\r\n    if (allCandidates.length === 0) {\r\n      return {\r\n        totalCrops: 0,\r\n        totalCandidates: 0,\r\n        uniqueTexts: 0,\r\n        avgCandidatesPerCrop: 0,\r\n        confidenceRange: { min: 0, max: 0, avg: 0 }\r\n      };\r\n    }\r\n\r\n    const uniqueTexts = new Set(allCandidates.map(c => c.text)).size;\r\n    const confidences = allCandidates.map(c => c.conf);\r\n\r\n    return {\r\n      totalCrops: candidates.length,\r\n      totalCandidates: allCandidates.length,\r\n      uniqueTexts,\r\n      avgCandidatesPerCrop: candidates.length > 0 ? allCandidates.length / candidates.length : 0,\r\n      confidenceRange: {\r\n        min: Math.min(...confidences),\r\n        max: Math.max(...confidences),\r\n        avg: confidences.reduce((sum, conf) => sum + conf, 0) / confidences.length\r\n      }\r\n    };\r\n  }\r\n\r\n  private createEmptyResult(): VoteResult {\r\n    return {\r\n      winner: '',\r\n      confidence: 0,\r\n      votes: {},\r\n      method: 'frequency',\r\n      candidates: []\r\n    };\r\n  }\r\n\r\n  // Method to simulate voting for demo purposes\r\n  simulateVote(expectedWinner: string): VoteResult {\r\n    const mockCandidates = [\r\n      { text: expectedWinner, count: 5, avgConfidence: 0.87, maxConfidence: 0.93 },\r\n      { text: expectedWinner.replace('‡¶∞', '‡¶¨'), count: 2, avgConfidence: 0.61, maxConfidence: 0.68 },\r\n      { text: expectedWinner.replace('‡¶Ø‡¶æ‡¶Ø‡¶º‡¶∞', '‡¶Ø‡¶æ‡¶Ø‡¶º‡¶¨'), count: 1, avgConfidence: 0.45, maxConfidence: 0.45 }\r\n    ];\r\n\r\n    return {\r\n      winner: expectedWinner,\r\n      confidence: 0.87,\r\n      votes: Object.fromEntries(mockCandidates.map(c => [c.text, c.count])),\r\n      method: 'frequency',\r\n      candidates: mockCandidates\r\n    };\r\n  }\r\n}\r\n","import { ROIPolygon, BBoxArray } from '@/types';\r\nimport { TraceLogger } from './TraceLogger';\r\n\r\nexport class ROI {\r\n  private polygon: ROIPolygon | null = null;\r\n  private logger: TraceLogger;\r\n  private canvas: HTMLCanvasElement | null = null;\r\n  private ctx: CanvasRenderingContext2D | null = null;\r\n  private isDrawing: boolean = false;\r\n  private tempPoints: Array<{ x: number; y: number }> = [];\r\n\r\n  constructor(logger: TraceLogger) {\r\n    this.logger = logger;\r\n  }\r\n\r\n  setCanvas(canvas: HTMLCanvasElement): void {\r\n    this.canvas = canvas;\r\n    this.ctx = canvas.getContext('2d');\r\n    this.logger.info('ROI', 'Canvas set', { \r\n      width: canvas.width, \r\n      height: canvas.height \r\n    });\r\n  }\r\n\r\n  startDrawing(): void {\r\n    if (!this.canvas) {\r\n      this.logger.error('ROI', 'Cannot start drawing without canvas');\r\n      return;\r\n    }\r\n\r\n    this.isDrawing = true;\r\n    this.tempPoints = [];\r\n    this.logger.info('ROI', 'Started drawing ROI');\r\n  }\r\n\r\n  addPoint(x: number, y: number): void {\r\n    if (!this.isDrawing) return;\r\n\r\n    this.tempPoints.push({ x, y });\r\n    this.logger.debug('ROI', 'Added point', { x, y, totalPoints: this.tempPoints.length });\r\n\r\n    // Draw temporary polygon\r\n    this.drawTempPolygon();\r\n  }\r\n\r\n  finishDrawing(): void {\r\n    if (!this.isDrawing || this.tempPoints.length < 3) {\r\n      this.logger.warn('ROI', 'Cannot finish ROI with less than 3 points');\r\n      return;\r\n    }\r\n\r\n    this.polygon = {\r\n      points: [...this.tempPoints],\r\n      active: true,\r\n      name: `ROI_${Date.now()}`\r\n    };\r\n\r\n    this.isDrawing = false;\r\n    this.tempPoints = [];\r\n\r\n    this.logger.info('ROI', 'ROI created', {\r\n      pointCount: this.polygon.points.length,\r\n      name: this.polygon.name\r\n    });\r\n  }\r\n\r\n  cancelDrawing(): void {\r\n    this.isDrawing = false;\r\n    this.tempPoints = [];\r\n    this.logger.info('ROI', 'Drawing cancelled');\r\n  }\r\n\r\n  private drawTempPolygon(): void {\r\n    if (!this.ctx || this.tempPoints.length === 0) return;\r\n\r\n    this.ctx.save();\r\n    this.ctx.strokeStyle = 'rgba(59, 130, 246, 0.8)';\r\n    this.ctx.lineWidth = 2;\r\n    this.ctx.setLineDash([5, 5]);\r\n\r\n    this.ctx.beginPath();\r\n    this.ctx.moveTo(this.tempPoints[0].x, this.tempPoints[0].y);\r\n    \r\n    for (let i = 1; i < this.tempPoints.length; i++) {\r\n      this.ctx.lineTo(this.tempPoints[i].x, this.tempPoints[i].y);\r\n    }\r\n\r\n    if (this.tempPoints.length > 2) {\r\n      this.ctx.closePath();\r\n      this.ctx.fillStyle = 'rgba(59, 130, 246, 0.1)';\r\n      this.ctx.fill();\r\n    }\r\n\r\n    this.ctx.stroke();\r\n\r\n    // Draw points\r\n    this.ctx.fillStyle = 'rgba(59, 130, 246, 1)';\r\n    this.tempPoints.forEach(point => {\r\n      this.ctx!.beginPath();\r\n      this.ctx!.arc(point.x, point.y, 4, 0, Math.PI * 2);\r\n      this.ctx!.fill();\r\n    });\r\n\r\n    this.ctx.restore();\r\n  }\r\n\r\n  drawROI(ctx?: CanvasRenderingContext2D): void {\r\n    const context = ctx || this.ctx;\r\n    if (!context || !this.polygon || !this.polygon.active) return;\r\n\r\n    context.save();\r\n    context.strokeStyle = 'rgba(59, 130, 246, 0.8)';\r\n    context.lineWidth = 2;\r\n    context.setLineDash([5, 5]);\r\n\r\n    context.beginPath();\r\n    context.moveTo(this.polygon.points[0].x, this.polygon.points[0].y);\r\n    \r\n    for (let i = 1; i < this.polygon.points.length; i++) {\r\n      context.lineTo(this.polygon.points[i].x, this.polygon.points[i].y);\r\n    }\r\n\r\n    context.closePath();\r\n    context.fillStyle = 'rgba(59, 130, 246, 0.1)';\r\n    context.fill();\r\n    context.stroke();\r\n\r\n    // Draw corner points\r\n    context.fillStyle = 'rgba(59, 130, 246, 1)';\r\n    this.polygon.points.forEach(point => {\r\n      context.beginPath();\r\n      context.arc(point.x, point.y, 3, 0, Math.PI * 2);\r\n      context.fill();\r\n    });\r\n\r\n    context.restore();\r\n  }\r\n\r\n  isPointInside(x: number, y: number): boolean {\r\n    if (!this.polygon || !this.polygon.active) {\r\n      return true; // If no ROI is set, consider all points as inside\r\n    }\r\n\r\n    return this.pointInPolygon(x, y, this.polygon.points);\r\n  }\r\n\r\n  isBBoxInside(bbox: BBoxArray, threshold: number = 0.5): boolean {\r\n    if (!this.polygon || !this.polygon.active) {\r\n      return true; // If no ROI is set, consider all boxes as inside\r\n    }\r\n\r\n    const [x1, y1, x2, y2] = bbox;\r\n    \r\n    // Check center point (most common approach)\r\n    const centerX = (x1 + x2) / 2;\r\n    const centerY = (y1 + y2) / 2;\r\n    \r\n    if (threshold === 0.5) {\r\n      return this.isPointInside(centerX, centerY);\r\n    }\r\n\r\n    // Check corners for threshold-based inclusion\r\n    const corners = [\r\n      { x: x1, y: y1 },\r\n      { x: x2, y: y1 },\r\n      { x: x2, y: y2 },\r\n      { x: x1, y: y2 }\r\n    ];\r\n\r\n    const insideCount = corners.filter(corner => \r\n      this.isPointInside(corner.x, corner.y)\r\n    ).length;\r\n\r\n    return (insideCount / 4) >= threshold;\r\n  }\r\n\r\n  private pointInPolygon(x: number, y: number, points: Array<{ x: number; y: number }>): boolean {\r\n    let inside = false;\r\n    \r\n    for (let i = 0, j = points.length - 1; i < points.length; j = i++) {\r\n      const xi = points[i].x;\r\n      const yi = points[i].y;\r\n      const xj = points[j].x;\r\n      const yj = points[j].y;\r\n      \r\n      const intersect = ((yi > y) !== (yj > y)) &&\r\n        (x < (xj - xi) * (y - yi) / (yj - yi) + xi);\r\n      \r\n      if (intersect) inside = !inside;\r\n    }\r\n    \r\n    return inside;\r\n  }\r\n\r\n  setPolygon(polygon: ROIPolygon): void {\r\n    this.polygon = polygon;\r\n    this.logger.info('ROI', 'Polygon set', {\r\n      pointCount: polygon.points.length,\r\n      active: polygon.active,\r\n      name: polygon.name\r\n    });\r\n  }\r\n\r\n  getPolygon(): ROIPolygon | null {\r\n    return this.polygon;\r\n  }\r\n\r\n  clearROI(): void {\r\n    this.polygon = null;\r\n    this.logger.info('ROI', 'ROI cleared');\r\n  }\r\n\r\n  toggleActive(): void {\r\n    if (this.polygon) {\r\n      this.polygon.active = !this.polygon.active;\r\n      this.logger.info('ROI', 'ROI toggled', { active: this.polygon.active });\r\n    }\r\n  }\r\n\r\n  saveToJSON(): string {\r\n    if (!this.polygon) {\r\n      this.logger.warn('ROI', 'No polygon to save');\r\n      return '{}';\r\n    }\r\n\r\n    return JSON.stringify(this.polygon, null, 2);\r\n  }\r\n\r\n  loadFromJSON(json: string): void {\r\n    try {\r\n      const polygon = JSON.parse(json) as ROIPolygon;\r\n      \r\n      if (!polygon.points || !Array.isArray(polygon.points)) {\r\n        throw new Error('Invalid polygon format');\r\n      }\r\n\r\n      this.polygon = polygon;\r\n      this.logger.info('ROI', 'Polygon loaded from JSON', {\r\n        pointCount: polygon.points.length,\r\n        active: polygon.active\r\n      });\r\n    } catch (error) {\r\n      this.logger.error('ROI', 'Failed to load polygon from JSON', { error });\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  // Scale polygon points (useful when canvas size changes)\r\n  scalePolygon(scaleX: number, scaleY: number): void {\r\n    if (!this.polygon) return;\r\n\r\n    this.polygon.points = this.polygon.points.map(point => ({\r\n      x: point.x * scaleX,\r\n      y: point.y * scaleY\r\n    }));\r\n\r\n    this.logger.info('ROI', 'Polygon scaled', { scaleX, scaleY });\r\n  }\r\n\r\n  // Get polygon bounds\r\n  getBounds(): { minX: number; minY: number; maxX: number; maxY: number } | null {\r\n    if (!this.polygon || this.polygon.points.length === 0) return null;\r\n\r\n    let minX = Infinity;\r\n    let minY = Infinity;\r\n    let maxX = -Infinity;\r\n    let maxY = -Infinity;\r\n\r\n    this.polygon.points.forEach(point => {\r\n      minX = Math.min(minX, point.x);\r\n      minY = Math.min(minY, point.y);\r\n      maxX = Math.max(maxX, point.x);\r\n      maxY = Math.max(maxY, point.y);\r\n    });\r\n\r\n    return { minX, minY, maxX, maxY };\r\n  }\r\n\r\n  // Get polygon area (using Shoelace formula)\r\n  getArea(): number {\r\n    if (!this.polygon || this.polygon.points.length < 3) return 0;\r\n\r\n    let area = 0;\r\n    const points = this.polygon.points;\r\n\r\n    for (let i = 0; i < points.length; i++) {\r\n      const j = (i + 1) % points.length;\r\n      area += points[i].x * points[j].y;\r\n      area -= points[j].x * points[i].y;\r\n    }\r\n\r\n    return Math.abs(area / 2);\r\n  }\r\n\r\n  // Check if polygon is valid (no self-intersections)\r\n  isValid(): boolean {\r\n    if (!this.polygon || this.polygon.points.length < 3) return false;\r\n\r\n    const points = this.polygon.points;\r\n\r\n    // Check for self-intersections\r\n    for (let i = 0; i < points.length; i++) {\r\n      const a1 = points[i];\r\n      const a2 = points[(i + 1) % points.length];\r\n\r\n      for (let j = i + 2; j < points.length; j++) {\r\n        if (i === 0 && j === points.length - 1) continue; // Skip adjacent edges\r\n\r\n        const b1 = points[j];\r\n        const b2 = points[(j + 1) % points.length];\r\n\r\n        if (this.linesIntersect(a1, a2, b1, b2)) {\r\n          return false;\r\n        }\r\n      }\r\n    }\r\n\r\n    return true;\r\n  }\r\n\r\n  private linesIntersect(\r\n    p1: { x: number; y: number },\r\n    p2: { x: number; y: number },\r\n    p3: { x: number; y: number },\r\n    p4: { x: number; y: number }\r\n  ): boolean {\r\n    const ccw = (A: { x: number; y: number }, B: { x: number; y: number }, C: { x: number; y: number }) => {\r\n      return (C.y - A.y) * (B.x - A.x) > (B.y - A.y) * (C.x - A.x);\r\n    };\r\n\r\n    return ccw(p1, p3, p4) !== ccw(p2, p3, p4) && ccw(p1, p2, p3) !== ccw(p1, p2, p4);\r\n  }\r\n}\r\n"],"names":["TraceLogger","maxLogs","__publicField","module","message","data","level","log","listener","filter","count","_a","_b","byLevel","byModule","startTime","endTime","time","ms","grouped","modules","index","moduleData","duration","moduleMetrics","name","totalDuration","DetectorPrecomputed","logger","url","_c","response","error","frame","bucket","timeMs","exactFrame","f","bucketFrame","nearestFrame","minDiff","diff","d","startMs","endMs","frames","frameBefore","frameAfter","alpha","interpolated","detBefore","detAfter","bbox","conf","totalDetections","plateDetections","vehicleDetections","timeRange","TrackerSimple","config","detections","track","unmatchedDetections","detection","bestMatch","bestIOU","iou","newTrack","trackId","finishedTracks","t","a","b","bbox1","bbox2","x1_1","y1_1","x2_1","y2_1","x1_2","y1_2","x2_2","y2_2","xLeft","yTop","xRight","yBottom","intersectionArea","area1","area2","unionArea","tracks","activeTracks","lostTracks","x","y","x1","y1","x2","y2","maxPoints","det","recent","prev","curr","vx1","vy1","vx2","vy2","OCRPrecomputed","videoId","baseUrl","sum","cropId","crop","c","candidates","best","current","allCandidates","totalCrops","totalCandidates","cropSum","allConfidences","avgConfidence","mockCandidates","Voter","textGroups","candidate","group","voteCandidates","text","winner","method","tiedCandidates","result","uniqueTexts","confidences","expectedWinner","ROI","canvas","i","point","ctx","context","threshold","centerX","centerY","corner","points","inside","j","xi","yi","xj","yj","polygon","json","scaleX","scaleY","minX","minY","maxX","maxY","area","a1","a2","b1","b2","p1","p2","p3","p4","ccw","A","B","C"],"mappings":"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"}